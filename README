This is a "plugin" for the Video Disk Recorder (VDR).

Written by:                  Lars Hanisch <dvb@flensrocker.de>

Project's homepage:          https://github.com/flensrocker/vdr-plugin-dbus2vdr

Latest version available at: git://github.com/flensrocker/vdr-plugin-dbus2vdr.git

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
See the file COPYING for more information.

Description:
This plugin will expose some methods via DBus to control the vdr.

Installation
------------
dbus2vdr will use the system bus so your box has to be configured that the user
in which context your vdr is running is allowed to connect to it.
Copy the de.tvdr.vdr.conf file to /etc/dbus-1/system.d and adjust it to your needs.
It is prepared that only the user 'vdr' can own the used destination and every user
can call its methods.

In the bin-directory you find a helper script for sending dbus messages to the vdr.
Instead of calling:
  dbus-send --system --type=method_call --dest=de.tvdr.vdr \
            --print-reply /Plugins/<pluginname> \
            de.tvdr.vdr.plugin.SVDRPCommand string:'command' string:'parameter'

you can call:
  vdr-dbus-send.sh /Plugins/<pluginname> plugin.SVDRPCommand string:'command' string:'parameter'

Dependencies
------------
Debian/Ubuntu packages:
libdbus-1-dev, pkg-config, libjpeg62-dev, libpng++-dev

Restrictions
------------
Objectpaths and interface names are restricted to some naming conventions. Only letters, numbers
and the underscore are allowed. DBus doesn't provide any official escaping, so dbus2vdr won't do it.
The only part of the names, which could contain other symbols are name of plugins. But "officially"
there are also no other characters than letters and numbers allowed. And I only knew about
streamdev-server/-client which break this rule. I think they should get fixed...

Commandline Arguments
---------------------
-s, --shutdown-hooks=/path/to/shutdown-hooks
        uses all files in the given directory as shutdown-hooks
        usually it's /usr/share/vdr/shutdown-hooks
-w, --shutdown-hooks-wrapper=/path/to/shutdown-hooks-wrapper
        path to a program that will call the shutdown-hooks with suid
-o, --osd
        creates an OSD-provider which will save the OSD as PNG files
        (see comments below at section "OSD")

Implemented features
--------------------
- send SVDRP commands to plugins
  vdr-dbus-send.sh /Plugins/<pluginname> plugin.SVDRPCommand string:'command' string:'parameter'

If the SVDRP command doesn't take a parameter you can ommit it or pass an empty string.

- call Service method of plugins
  vdr-dbus-send.sh /Plugins/<pluginname> plugin.Service string:'id' string:'data'

- disable EIT scanner with timeout (default: 3600)
  vdr-dbus-send.sh /EPG epg.DisableScanner int32:3600

- enable EIT scanner
  vdr-dbus-send.sh /EPG epg.EnableScanner

- clear EPG data with optional value for inactivity timeout of eit-scanner (default: 10)
  vdr-dbus-send.sh /EPG epg.ClearEPG string:'channel' int32:10

- add EPG entry
  vdr-dbus-send.sh /EPG epg.PutEntry string:'C ...' string:'E ...' ...

  The end marker argument '.' will be added if not provided.

- read EPG data from file
  vdr-dbus-send.sh /EPG epg.PutFile string:'/path/to/epg/data'

- get current or next event of given or all channels
  vdr-dbus-send.sh /EPG epg.Now [string:'channel']
  vdr-dbus-send.sh /EPG epg.Next [string:'channel']
  vdr-dbus-send.sh /EPG epg.At [string:'channel'] uint64:time

  The events are returned as an array of structs.
  Each struct contains a string as a key and a variant as its value.
  Possible keys and their variant type are:
  ChannelID      string
  EventID        uint32
  Title          string
  ShortText      string
  Description    string
  StartTime      uint64
  EndTime        uint64
  Duration       uint64
  Vps            uint64
  RunningStatus  int32
  ParentalRating int32
  ContentID[i]   int32  (0 <= i <= MaxEventContents)
  Content[i]     string (0 <= i <= MaxEventContents)

- get infos about the next timer
  vdr-dbus-send.sh /Timers timer.Next

  The following is returned:
    int32   reply code (250 for success, 550 on error)
    int32   timer id (-1 if there's no timer at all)
    int32   'rel' seconds (see SVDRP NEXT REL)
    uint64  starttime in seconds since epoch (time_t format)
    uint64  stoptime in seconds since epoch (time_t format)
    string  title of the event

- enable/disable the remote
  vdr-dbus-send.sh /Remote remote.Enable
  vdr-dbus-send.sh /Remote remote.Disable
  vdr-dbus-send.sh /Remote remote.Status

- hit a key, you may specify more than one key
  vdr-dbus-send.sh /Remote remote.HitKey string:'Menu' string:'Down' string:'Down' ...

- display list of strings on the osd and let the user select one
  vdr-dbus-send.sh /Remote remote.AskUser string:'title' string:'item 1' string:'item 2' ...

  The zero-based index of the selected item will be returned with the signal "AskUserSelect",
  the first parameter is the title-string, the second the index.
  An index of -1 means, no item is selected (or osd closed because of a timeout).

- open the main menu entry of a plugin
  vdr-dbus-send.sh /Remote remote.CallPlugin string:'name-of-plugin'

- trigger an update of the list of recordings
  vdr-dbus-send.sh /Recording recording.Update

- display a message at the OSD
  vdr-dbus-send.sh /Skin skin.QueueMessage string:'message text'

- get information about available skins
  vdr-dbus-send.sh /Skin skin.ListSkins
  You will get an array of index, name and description.

- get information about current skin
  vdr-dbus-send.sh /Skin skin.CurrentSkin
  You will get the index, name and description.

- ask vdr if it is ready for shutdown
  vdr-dbus-send.sh /Shutdown shutdown.ConfirmShutdown
  possible reply codes:
    250: vdr is ready for shutdown
    550: vdr is not ready for shutdown (unknown reason)
    901: user is active
    902: cutter is active
    903: recording is active
    904: recording is active in the near future
    905: some plugin is active
    906: some plugin will wakeup vdr in the near future
    990: (reply message contains SHUTDOWNCMD)
    991: (reply message contains TRY_AGAIN of the shutdown-hooks)
    992: (reply message contains ABORT_MESSAGE of the shutdown-hooks)
    999: shutdown-hook returned a non-zero exit code

  You may shutdown vdr on reply codes 250 and 990.
  If SHUTDOWNCMD is given use this command for shutdown.
  'shutdown-wrapper' is a tool which calls the shutdown-hooks.
  If the hooks need elevated privileges set the SUID bit of the wrapper accordingly.

- list all supported parameters from setup.conf
  vdr-dbus-send.sh /Setup setup.List

- get parameters from setup.conf
  vdr-dbus-send.sh /Setup setup.Get string:'MinUserInactivity'

- set parameters to setup.conf
  vdr-dbus-send.sh /Setup setup.Set string:'MinUserInactivity' int32:0
  (look at setup.c for the supported parameters)

OSD
---
If started with the parameter "--osd" dbus2vdr will create an OSD-provider.
If you have another output plugin running, this is not recommended since it may
override its OSD-provider. For now it's just for fun (or a headless vdr).
If the vdr opens an OSD, dbus2vdr will dump the pixmap to a PNG file and signals this.
Every change at the OSD will generate another PNG and signal. If the OSD closes all
files will be deleted.
Every image between "Open" and "Close" has to be displayed on top of its predecessors.

- create the DBus-OSD-provider on the fly
  vdr-dbus-send.sh /OSD osd.CreateProvider

- delete the DBus-OSD-provider and reinstantiate the OSD-provider of the primary device
  vdr-dbus-send.sh /OSD osd.DeleteProvider

interface: de.tvdr.vdr.osd
path: /OSD

signal: Open
parameter: osd-id   (string, actually the path where the PNGs will be stored)
           left     (int32, left position of OSD)
           top      (int32, top position of OSD)

signal: Display
parameter: filename (string)
           left     (int32)
           top      (int32)
           vx       (int32, x-coordinate of dirty part relative to left)
           vy       (int32, y-coordinate of dirty part relative to top)

signal: Close
parameter: osd-id   (string)

You can watch the signals with (or write your own program):
  dbus-monitor --system "type='signal',sender='de.tvdr.vdr',interface='de.tvdr.vdr.osd'"

Since the DBus signals are not really "fast" the files may not exist anymore if you
receive them.

Using the Python binding
------------------------
First, I don't know Python at all, I just copy code fragments from the Python Binding Tutorial [1]
and replace the sample strings with dbus2vdr related ones. I hope everybody familiar with Python
will know what to do...

  import dbus
  bus = dbus.SystemBus()
  Timers = bus.get_object('de.tvdr.vdr', '/Timers')
  props = Timers.Next(dbus_interface = 'de.tvdr.vdr.timer')
  # props is now a tuple with data like mentioned above

How to implement new interfaces
-------------------------------
- add the interface name to common.h
- create a subclass of cDBusMessageDispatcher and pass the interface name
  to its base constructor
- return subclasses of cDBusMessage in its CreateMessage method depending
  on object path, method name etc.
- return introspection data in OnIntrospect
- add your code to the Process method of your cDBusMessage classes
- add a 'new cDBusDispatcherYourName' to cPluginDbus2vdr::Start

Notes to myself
---------------
to use dbus in a ssh-shell:
look at ~/.dbus/session-bus/`dbus-uuidgen-get`-... and export DBUS_SESSION_BUS_ADDRESS

Links
-----
[1] http://dbus.freedesktop.org/doc/dbus-python/doc/tutorial.txt
